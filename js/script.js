"use strict"

// Чет прям ну очень сложно, методом тыка вроде что то получается, но как работает под капотом не пойму.
// Пока похоже, что мы можем просто объявить пустую функцию, и дальше тупо работать с ней как с объектом.
// TODO: Я в упор не понимаю, в какой жопе это все хранится?
// Кажется понемногу доходит.

//=============================TASKS=================================================================================================================================================
console.log('==================NEXT TASK====================');

function makeCounter() { //Это функция для создания других функций. Если не ошибаюсь то это функция конструктор.

	let count = 0;

	function cntr() {}; // Нам нужно просто создать какую то функцию что бы было что возвращать конструктору, что бы было что привязать к переменной, и что бы было к чему наваливать методы.

	cntr.number = 0; // Пока не нужно, переписал все на замыкание, пусть висит.
					// Используем свойство функции-объекта как хранилище значения счетчика, потому что если хранить в замыкании, тоя не могу понять как потом вывести значение в консоль,
					// т.к. по идее замыкания, к нему нет доступа ничему и ниоткуда, кроме той функции с которой это значение замкнуто. То есть я в общем то смогу инкрементить его, но не могу посмотреть.
					// TODO: а если создать в замыкании метод, который будет выводить значение в консоль?
					// ооо, кажись работает.

	cntr.tick = () => count++; //Наваливаем метод, который будет инкрементить
	cntr.set = (value) => count = value; //Метод, который будет присваивать счетчику указанное значение
	cntr.decrease = () => count--; //Метод будет декрементить
	cntr.show = () => console.log(count); // Метод что бы посмотреть "шотамвзамыкании"
	cntr.get = () => count; // Что бы выковырнуть значение из замыкания. В общем то получается, что метод .show не нужен, но пусть пока остается.

	return cntr;
};


let counter = makeCounter();
console.log(counter);

counter.tick();
counter.tick();
counter.tick();
console.log(counter.tick);
counter.show();

counter.set(200);
counter.show();


counter.tick();
counter.tick();
counter.tick();
let counterVal = counter.get();
console.log(counterVal);

//console.log(counter.number);
//console.log(counter.number);



//=============================TASKS=================================================================================================================================================
console.log('==================NEXT TASK====================');

function sum(a) { 			// Создаем функцию. Что бы эта шляпа хоть как то работала, а не сразу отлетала, нужно что бы она возвращала какую-то функцию, не вызывая ее (без скобок), 
							// потому что скобки и так будут добавляться.
							// Задумка в том, что пока в строке с вызовом будут идти новые скобки возвращенная функция будет именно вызываться, с параметрами в скобках.
							// Как только скобки кончаться, функция вернет сама себя без вызова.
							// Что бы она вернул результат, пишем к ней метод .toString, который вернет накопленное значение.
							// Плюс по условиям задачи результат выводится через alert, который автоматически пытается преобразовать в строку.
							// При выводе в консоль, преобразование нужно добавлять вручную.
							// Вообще какая-то странная задача, и по сути даже ответ из решения не удовлетворяет условию, т.к. функция не вернет сама собой накопленное значение, а ждет пинка
							// в виде преобразования в строку.
							// TODO: попробовать что-то придумать с тем, что бы функция без пинка возвращала накопленное значение.
							// 1) без понятия как проверить будет ли вызов функции, или она будет без вызова. Наверное это невозможно.
							// 2) функция должна вернуть другую функцию без вызова, иначе дальше сразу будет ошибка. Безопасно вернуть значение можно только если дальше не будет попыток вызова, НО см.п.1 :(

	let value = a;
	function f(b) {
		value += b;
		return f;
	};

	f.toString = function() {
		return value;
	};

	return f;
}

console.log(sum);
alert( sum(1)(2) );
sum(1)(2) // 3; 
sum(1)(2)(3) // 6; 
sum(5)(-1)(2) // 6
sum(6)(-1)(-2)(-3) // 0
sum(0)(1)(2)(3)(4)(5) // 15
console.log((sum(1)(2)).toString());




